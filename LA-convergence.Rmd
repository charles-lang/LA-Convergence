---
title: "LA Convergence"
output: html_document
date: "2024-07-10"
---
## To Do

SNA
1. Build clean data set of all sources (LAK, HLA, JLA)
2. Build paper-paper network
2b. Check that the number of papers in the network = the number in the dataset
3. Cluster network into outer (unconnected), outer clusters, core
3b. Cluster the network according to the source (LAK, HLA, JLA)
4. Cluster core into 6-10 communities with defensible methodology
5. Line graph of growth of clusters over time
6. Calculate number of uncconected papers that become connected each year
7. Assign community label to each paper

Topic Model
1. Build topic model of all sources (LAK, HLA, JLA)
2. Look at distribution for each source (LAK, HLA, JLA)
3. Graph growth of topics over time
4. Assign topic to communities for total data set
5. Track movement of communities across topic space over time
6. Map movement of communities across topic space over time

###Libraries
```{r}
library(tidyverse)
library(readxl)
library(igraph)
library(janitor)
library(plotly)
library(RColorBrewer)
library(sand)
library(grDevices)
library(visNetwork)
```

###Data Cleaning and Structuring
```{r}
L1 <- read_excel("LAK data_cleaned.xlsx")

L1 <- L1 |> mutate(Series = if_else(startsWith(Series, "LAK"), "LAK", Series))
L1$color <- ifelse(L1$Series == "LAK", "#66c2a5", ifelse(L1$Series == "JLA", "#fc8d62", "#8da0cb"))
L1$id <- seq(1,nrow(L1),1)
L1$id <- paste0("P",L1$id)

#Individual LAK years
#L2 <- L1 %>% filter(Series == "LAK '11" | Series == "LAK '12" | Series == "LAK '13" | Series == "LAK '14" | Series == "LAK '15" | Series == "LAK '16" | Series == "LAK '17" | Series == "LAK '18" | Series == "LAK '19" | Series == "LAK '20" | Series == "LAK 21" | Series == "LAK 22" | Series == "LAK 2023" | Series == "LAK '24")

#Select just LAK
#L2 <- L1 %>% filter(substr(Series,1,1) == "L")
  
L2 <- select(L1, Authors, `Publication Year`)

L2$id <- seq(1,nrow(L2),1)
L2$id <- paste0("P",L2$id)

L3 <- L2 %>% add_column(author = L2$Authors %>% str_split(';', simplify = T))
#L3 <- as.data.frame(L3)

L4 <- L3 %>%
  mutate_at("author", as.data.frame) |> 
  unnest(author)

#L4 <- bind_rows(replicate(13,L3, simplify=F)) 

L4 <- L4 %>% select(-Authors)

L5 <- L4 %>%
  pivot_longer(
    cols = 3:6,
    names_to = "author_number",
    values_to = "author"
  )

L5 <- filter(L5, author != "")

L6 <- select(L5, id, author)
L6$value <- 1

L6 <- pivot_wider(L6, names_from = author, values_from = value)
L6 <- column_to_rownames(L6, "id")

#rownames(L6) <- L6$id

M6 <- as.matrix(L6)
M6[is.na(M6)]<-0

#Author-Author Matrix

M7 <- t(M6) %*% M6

diag(M7) <- NA

#Paper-Paper Network

M8 <- M6 %*% t(M6)

diag(M8) <- NA

```

### Paper-Paper Network
```{r}
g2 <- graph_from_adjacency_matrix(
  M8,
  mode = c("undirected"),
  weighted = NULL,
  diag = TRUE,
  add.colnames = NULL,
  add.rownames = NA
)

#Basic Plot
plot(g2, vertex.size=2, vertex.label=NA)

#Plot according to source (LAK, JLA, HLA)

V1 <- as_data_frame(g2, what="vertices")
E1 <- as_data_frame(g2, what="edges")  

V1$color <- L1$color

g3 <- graph_from_data_frame(E1, directed = FALSE, vertices = V1)

plot(g3, vertex.size=5, vertex.label=NA, vertex.color = V1$color)

#Plot by major structural group

degree_centrality <- degree(g3)

node_colors <- ifelse(degree_centrality == 0, "#66c2a5", "#fc8d62")

plot(g3, vertex.size=5, vertex.label=NA, vertex.color = node_colors, main = "Disconnected Nodes")

closeness_centrality <- closeness(g3)

closeness_centrality[!is.finite(closeness_centrality)] <- 1

if (any(!is.finite(closeness_centrality))) {
  stop("Closeness centrality contains non-finite values.")
}

hist(closeness_centrality, breaks = 100)

node_colors <- ifelse(closeness_centrality < 0.05, "#66c2a5", "#fc8d62")

plot(g3, vertex.size=5, vertex.label=NA, vertex.color = node_colors, main = "Core - closeness < 0.05")

node_colors <- ifelse(closeness_centrality < 0.05, "#66c2a5", ifelse(degree_centrality == 0, "#fc8d62", "#8da0cb"))

plot(g3, vertex.size=5, vertex.label=NA, vertex.color = node_colors, main = "Three Structures")

#Table of series vs structure
V1$structure <- ifelse(closeness_centrality < 0.05, "core", ifelse(degree_centrality == 0, "isolates", "isolated cluster"))

table(V1$color,V1$structure)


#Isolate isolated clusters
Isolated = which(closeness(g3) < 0.05 | degree(g3) == 0)
g4 = delete.vertices(g3, Isolated)

hist(degree(g4))

plot(g4, vertex.size=5, vertex.label=NA, main = "Isolated Clusters")

#Core
Isolated = which(closeness(g3) > 0.05 & degree(g3) != 0 | degree(g2) == 0)
g5 = delete.vertices(g3, Isolated)

plot(g5, layout=layout_nicely(g5), vertex.size=3, vertex.label=NA, edge.width = 0.1, main = "Core")


```
###Community Detection
```{r}
matrix_spinglass <- matrix(NA, nrow=1,ncol=100)
 
for (i in 1:100) {
set.seed(i)
spinglass <- spinglass.community(g5, gamma = 0.05)
matrix_spinglass[1,i] <- max(spinglass$membership) 
}
 
mean(as.vector(matrix_spinglass)) #14.95
max(as.vector(matrix_spinglass)) #19
min(as.vector(matrix_spinglass)) #10
median(as.vector(matrix_spinglass)) #15

csg <- g5 %>% cluster_spinglass(spins = 15)

plot(csg, g5, vertex.size=1.5, edgeth.width = 0.1, vertex.label=NA)

```
###Plot by communities
```{r}
COMP = components(g3)
table(COMP$membership)

SC = which(COMP$membership != 1)
SmallComps = induced_subgraph(g3, SC)

SC.gn.comm <- cluster_edge_betweenness(SmallComps)
colors <- rainbow(max(membership(SC.gn.comm)))
plot(SC.gn.comm, SmallComps, vertex.size = 6, 
    vertex.color=colors[membership(SC.gn.comm)], 
    vertex.label = NA, edge.width = 1)

LC = which(COMP$membership == 1)
LargeComp = induced_subgraph(g3, LC)

LC.gn.comm <- cluster_edge_betweenness(LargeComp)
max(LC.gn.comm$membership)

colors <- rainbow(max(membership(LC.gn.comm)))
set.seed(1234)
plot(LC.gn.comm, LargeComp, vertex.size = 6, 
    vertex.color=colors[membership(LC.gn.comm)], 
    vertex.label = NA, edge.width = 1)

LC_Grouped = LargeComp
E(LC_Grouped)$weight = 1
for(i in unique(membership(LC.gn.comm))) {
    GroupV = which(membership(LC.gn.comm) == i)
    LC_Grouped = add_edges(LC_Grouped, combn(GroupV, 2), attr=list(weight=6))
} 

set.seed(1234)
LO = layout_with_fr(LC_Grouped)
colors <- rainbow(max(membership(LC.gn.comm)))
par(mar=c(0,0,0,0))
plot(LC.gn.comm, LargeComp, layout=LO,
    vertex.size = 6, 
    vertex.color=colors[membership(LC.gn.comm)], 
    vertex.label = NA, edge.width = 1)

GN.Comm = simplify(contract(LargeComp, membership(LC.gn.comm)))
D = unname(degree(GN.Comm))

set.seed(1234)
par(mar=c(0,0,0,0))
plot(GN.Comm, vertex.size=2*sqrt(sizes(LC.gn.comm)),
    vertex.label=1:43, vertex.cex = 0.8,
    vertex.color=round(log(D))+1)

```



###Author-Author Network
```{r}
g1 <- graph_from_adjacency_matrix(
  M7,
  mode = c("undirected"),
  weighted = NULL,
  diag = TRUE,
  add.colnames = NULL,
  add.rownames = NA
)

plot(g1, vertex.size=5, vertex.label=NA)

Isolated = which(degree(g1)==0)
g2 = delete.vertices(g1, Isolated)

plot(g2, layout=layout_with_fr(g1), vertex.size=1, edge.width = 0.1, vertex.label=NA)

Isolated2 = which(degree(g1) > 1)
g3 = delete.vertices(g1, Isolated2)

plot(g3, layout=layout_with_fr(g1), vertex.size=1, edge.width = 0.1, vertex.label=NA)

Isolated3 = which(degree(g1) > 2)
g4 = delete.vertices(g1, Isolated3)

plot(g4, layout=layout_with_fr(g1), vertex.size=1, edge.width = 0.1, vertex.label=NA)

Isolated4 = which(closeness(g1) > 0.04)
g5 = delete.vertices(g1, Isolated4)

plot(g5, vertex.size=2, edge.width = 0.2, vertex.label=NA)


closeness_centrality <- closeness(g1)

closeness_centrality[!is.finite(closeness_centrality)] <- 1

if (any(!is.finite(closeness_centrality))) {
  stop("Closeness centrality contains non-finite values.")
}

closeness_centrality_normalized <- (closeness_centrality - min(closeness_centrality)) / (max(closeness_centrality) - min(closeness_centrality))



node_colors <- ifelse(closeness_centrality < 0.04, "blue", ifelse(closeness_centrality >= 0.04 & closeness_centrality < 0.6, "red", "green"))
  
  #colorRampPalette(c("blue", "red"))(100)[as.numeric(cut(closeness_centrality_normalized, breaks = 1))]

plot(g1, vertex.size=3, vertex.label=NA, vertex.color = node_colors, main = "Nodes Colored by Closeness Centrality")

hist(closeness_centrality_normalized)

degree_centrality <- degree(g1)

node_colors <- ifelse(degree_centrality < 1, "blue", "red")

plot(g1, vertex.size=3, vertex.color = node_colors, vertex.label.cex = 0.3, main = "Nodes Colored by Degree Centrality")

```
###Network Metrics
```{r}
clu <- components(g1)
groups(clu)

hist(degree(g1), breaks =100)

hist(closeness(g1), breaks =100)

hist(betweenness(g1), breaks =100)

hist(degree(g2), breaks =100)

hist(closeness(g2), breaks =10)

hist(betweenness(g2), breaks =100)

```


###Community Structure
```{r}
kc <- cluster_leiden(g5)

n <- length(V(g5))

kc <- cluster_leiden(g5, 
                     resolution_parameter = sum(E(g1)$weight)/(n*(n-1)/2))


length(kc)

plot(kc,g5, vertex.size=1, edge.width = 0.1, vertex.label=NA)

kc2 <- cluster_leiden(g5, objective_function = "modularity",
                       n_iterations = 3, resolution_parameter = 0.5)
plot(kc2,g5, vertex.size=1, edge.width = 0.1, vertex.label=NA)

length(kc2)

kc3 <- cluster_leiden(g5, objective_function = "modularity",
                       n_iterations = 3, resolution_parameter = 0.75)
plot(kc3,g5,vertex.size=1, edge.width = 0.1, vertex.label=NA)

kc4 <- cluster_leiden(g5, objective_function = "modularity",
                       n_iterations = 3, resolution_parameter = 1.0)
plot(kc4,g5,vertex.size=1, edge.width = 0.1, vertex.label=NA)

kc5 <- cluster_leiden(g5, objective_function = "modularity",
                       n_iterations = 3, resolution_parameter = 1.5)
plot(kc5,g5,vertex.size=1, edge.width = 0.1, vertex.label.cex = 0.5)

length(kc5)

kc6 <- cluster_leiden(g5, objective_function = "modularity",
                       n_iterations = 3, resolution_parameter = 1.5)
plot(kc6,g5,vertex.size=1, edge.width = 0.1, vertex.label.cex = 0.5)
length(kc6)

kc7 <- cluster_leiden(g5, 
                     resolution_parameter = sum(E(g1)$weight)/(n*(n-1)/2))
plot(kc7, g5, vertex.size=1, edge.width = 0.1, vertex.label.cex = 0.5)

ebc1 <- edge.betweenness.community(g5, directed = F)

plot(ebc1, g5, vertex.size=1, edge.width = 0.1, vertex.label= NA)

wc1 <- walktrap.community(g5)

plot(wc1, g5, vertex.size=1, edge.width = 0.1, vertex.label= NA)

#Winner
lec1 <- leading.eigenvector.community(g5)

plot(lec1, g5, vertex.size=1, edge.width = 0.1, vertex.label.cex = 0.3)

lpc <- label.propagation.community(g5)

plot(lpc, g5, vertex.size=1, edge.width = 0.1, vertex.label= NA)

```


```{r}

#Cut out core of network
Isolated = which(closeness(g2) > 0.02 & degree(g2) != 0 | degree(g2) == 0)
g2b = delete.vertices(g2, Isolated)

plot(g2b, vertex.size=5, vertex.label=NA)

length(g2b)

lpc <- label.propagation.community(g2b)

length(lpc)

plot(lpc, g2b, vertex.size=1, edge.width = 0.1, vertex.label= NA)

csg1 <- g2b %>% cluster_spinglass(spins = 8)

plot(csg1, g2b, vertex.size=5, vertex.label=NA)

plot_ly(g2b)

n <- length(V(g2b))

csg2 <- cluster_spinglass(g2b, gamma = 0.3)

plot(csg2, g2b, vertex.size=5, vertex.label=NA)

length(csg2)

#kc <- cluster_leiden(g2b, resolution_parameter = 0.001)

#length(kc)

#plot(kc,g2b, vertex.size=1, edge.width = 0.1, vertex.label=NA)

matrix_spinglass <- matrix(NA, nrow=1,ncol=100)
 
for (i in 1:100) {
set.seed(i)
spinglass <- spinglass.community(g2b, gamma = 0.01)
matrix_spinglass[1,i] <- max(spinglass$membership) 
}
 
mean(as.vector(matrix_spinglass))
max(as.vector(matrix_spinglass)) 
min(as.vector(matrix_spinglass))
median(as.vector(matrix_spinglass))

matrix(NA, nrow=1,ncol=100)

plot(g5, 
     vertex.label = NA,
     edge.color = 'gray',
     vertex.size = 0.04*sqrt(betweenness(g5))+1,
     edge.arrow.size = 0.05,
     layout = layout_nicely(g5))

```
##Separate by Communities
```{r}
E(LC_Grouped)$weight = 1
for(i in unique(membership(LC.gn.comm))) {
    GroupV = which(membership(LC.gn.comm) == i)
    LC_Grouped = add_edges(LC_Grouped, combn(GroupV, 2), attr=list(weight=6))
} 

set.seed(1234)
LO = layout_with_fr(LC_Grouped)
colors <- rainbow(max(membership(LC.gn.comm)))
par(mar=c(0,0,0,0))
plot(LC.gn.comm, LargeComp, layout=LO,
    vertex.size = 6, 
    vertex.color=colors[membership(LC.gn.comm)], 
    vertex.label = NA, edge.width = 1)


```


Plotly
```{r}
layout <- layout_with_fr(g2b)

nodes <- data.frame(id = V(g2b)$name, 
                    x = layout[, 1], 
                    y = layout[, 2])


edges <- data.frame(
  source = as.character(ends(g2b, es = E(g2b))[, 1]),
  target = as.character(ends(g2b, es = E(g2b))[, 2])
)

fig <- plot_ly(type = 'scatter', mode = 'markers+text')

fig <- fig %>% 
  add_trace(
    x = ~nodes$x,
    y = ~nodes$y,
    text = ~nodes$id,
    textposition = "top center",
    marker = list(size = 10, color = 'blue'),
    type = 'scatter'
  )

# Add edges
for (i in 1:nrow(edges)) {
  fig <- fig %>%
    add_trace(
      x = c(nodes[nodes$id == edges$source[i], ]$x, nodes[nodes$id == edges$target[i], ]$x),
      y = c(nodes[nodes$id == edges$source[i], ]$y, nodes[nodes$id == edges$target[i], ]$y),
      mode = 'lines',
      line = list(color = 'black')
    )
}

# Show the plot
fig

```

###OFFCUTS
```{r}
lec1 <- leading.eigenvector.community(g2, weights = NULL)

plot(lec1, g2, vertex.size=1, edge.width = 0.1, vertex.label=NA)

ebc1 <- edge.betweenness.community(g2, directed = F)

plot(ebc1, g2, vertex.size=1, edge.width = 0.1, vertex.label= NA)

lou <- cluster_louvain(g2)

plot(lou, g2, vertex.size=5, edge.width = 0.1, vertex.label= NA)



Small = which(table(lou$membership) < 20)
Keep = V(g2)[!(lou$membership %in% Small)]

gD2  = induced_subgraph(g2, Keep)
lou2 = cluster_louvain(gD2)
LO = layout_with_fr(g2)
LO2 = LO[Keep,]
plot(lou2, gD2, vertex.label = NA, vertex.size=5, 
    edge.arrow.size = .2, layout=LO2)


Isolated = which(degree(g2) < 5)
g3 = delete.vertices(g2, Isolated)

plot(g3, vertex.size=5, vertex.label=NA)

csg1 <- gD2 %>% cluster_spinglass(spins = 6)

plot(csg1, gD2, vertex.size=5, vertex.label=NA)

closeness_centrality <- closeness(g2)

closeness_centrality[!is.finite(closeness_centrality)] <- 1

if (any(!is.finite(closeness_centrality))) {
  stop("Closeness centrality contains non-finite values.")
}

closeness_centrality_normalized <- (closeness_centrality - min(closeness_centrality)) / (max(closeness_centrality) - min(closeness_centrality))



node_colors <- ifelse(closeness_centrality < 0.02, "blue", ifelse(closeness_centrality >= 0.02 & closeness_centrality < 1, "red", "green"))
  
  #colorRampPalette(c("blue", "red"))(100)[as.numeric(cut(closeness_centrality_normalized, breaks = 1))]

plot(g2, vertex.size=3, vertex.label=NA, vertex.color = node_colors, main = "Nodes Colored by Closeness Centrality")

degree_centrality <- degree(g2)

degree_centrality_normalized <- (degree_centrality - min(degree_centrality)) / (max(degree_centrality) - min(degree_centrality))

hist(degree_centrality, breaks = 100)
table(degree_centrality)
hist(degree_centrality_normalized, breaks = 100)

node_colors <- ifelse(degree_centrality_normalized < 0.01, "blue", ifelse(degree_centrality_normalized >= 0.01 & degree_centrality_normalized < 0.02, "red", "green"))
  
  #colorRampPalette(c("blue", "red"))(100)[as.numeric(cut(closeness_centrality_normalized, breaks = 1))]

plot(g2, vertex.size=3, vertex.label=NA, vertex.color = node_colors, main = "Nodes Colored by Degree Centrality")



node_colors <- ifelse(degree_centrality_normalized == 0, "green", ifelse(degree_centrality_normalized != 0 & closeness_centrality < 0.1, "red", "blue"))
                      
                

plot(g2, vertex.size=3, vertex.label=NA, vertex.color = node_colors, main = "Nodes Colored by Degree/Closeness Centrality")

hist(closeness_centrality, breaks = 100)
```

